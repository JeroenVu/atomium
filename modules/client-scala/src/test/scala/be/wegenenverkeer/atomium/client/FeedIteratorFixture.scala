package be.wegenenverkeer.atomium.client

import be.wegenenverkeer.atomium.client.FeedEntryIterator.Implicits._
import be.wegenenverkeer.atomium.format.{Feed, Link, Url}
import be.wegenenverkeer.atomium.server.{Context, FeedService, MemoryFeedStore}
import org.joda.time.DateTime

import scala.util.{Success, Try}

/**
 * A trait fixture to be used on tests requiring a [[be.wegenenverkeer.atomium.client.FeedEntryIterator]] or eventually
 * an [[be.wegenenverkeer.atomium.client.async.AsyncFeedEntryIterator]].
 *
 * It's backed by a blocking in-memory [[MemoryFeedStore]] and [[FeedService]].
 *
 * Entries must be pushed prior to the initialization of the `Iterator`.
 *
 * {{{
 *
 *  import scala.concurrent.duration._
 *
 *  new FeedIteratorFixture[String] {
 *
 *    push("a1", "b1", "c1", "a2", "b2", "c2")
 *
 *    // start an iterator from the least recent entry
 *    // will iterate over all entries starting at 'a1' and ending at 'c2'
 *    val iter1 = iteratorFromStart
 *
 *    // start an iterator from 'c1'
 *    // will iterate over 'a2', 'b2' and 'c2'
 *    val iter2 = iteratorStartingFrom("c1")
 *  }
 *
 * }}}
 *
 *
 * Entry ids are automatically generated by the `FeedStore`. In case you need to retrieve the id
 * for a given entry. You can find it by entry content value.
 *
 * {{{
 *
 *  import scala.concurrent.duration._
 *
 *  new FeedIteratorFixture[String] {
 *
 *    push("a1", "b1", "c1", "a2", "b2", "c2")
 *
 *    val entryRef = iteratorFromStart.findByValue("c1")
 *    val id = entryRef.entryId
 *  }
 * }}}
 *
 *
 * Note: although the backing `FeedStore`,  `FeedService` and `FeedProvider` are blocking, the underlying
 * iterator is not. Therefore, you can request a async iterator in case your tests requires one.
 *
 * *
 * {{{
 *
 *  import scala.concurrent.duration._
 *
 *  new FeedIteratorFixture[String] {
 *
 *    push("a1", "b1", "c1", "a2", "b2", "c2")
 *
 *    val asyncIter = iteratorFromStart.asyncIterator
 *  }
 * }}}
 *
 * @tparam E the type of the Feed content value.
 */
trait FeedIteratorFixture[E] extends FeedProviderFixture[E] {


  def iteratorFromStart: FeedEntryIterator[E] = {
    new TestFeedProvider().iterator()
  }

  def iteratorStartingFrom(entryRef: Option[EntryRef[E]]): FeedEntryIterator[E] = {
    new TestFeedProvider().iterator(entryRef)
  }

  def iteratorStartingFrom(entryValue: E): FeedEntryIterator[E] = {
    // force NoSuchElementException if there is no such entry
    val entry = findByValue(_ == entryValue).get
    iteratorStartingFrom(Some(entry))
  }

  def findByValue(f: (E) => Boolean): Option[EntryRef[E]] = {
    iteratorFromStart.find { entryRef =>
      f(entryRef.entry.get.content.value)
    }
  }




}
